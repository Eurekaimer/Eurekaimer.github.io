<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>KNN Interactive Visualizer</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <!-- React & ReactDOM (UMD) -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- D3.js -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    
    <!-- Babel Standalone for compiling JSX in browser -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
      body {
        font-family: 'Inter', sans-serif;
        margin: 0;
        padding: 0;
        overflow: hidden; /* Prevent body scroll if iframe handles it */
      }
    </style>
  <script type="importmap">
{
  "imports": {
    "react": "https://aistudiocdn.com/react@^19.2.0",
    "react-dom/": "https://aistudiocdn.com/react-dom@^19.2.0/",
    "react/": "https://aistudiocdn.com/react@^19.2.0/",
    "lucide-react": "https://aistudiocdn.com/lucide-react@^0.555.0",
    "d3": "https://aistudiocdn.com/d3@^7.9.0"
  }
}
</script>
</head>
  <body class="bg-slate-50 text-slate-900 antialiased h-screen w-full">
    <div id="root" class="h-full w-full"></div>

    <script type="text/babel" data-presets="typescript,react">
      const { useState, useEffect, useMemo, useRef, useCallback } = React;

      // --- TYPES & CONSTANTS ---
      
      const CLASS_COLORS = {
        A: '#ef4444', // Red-500
        B: '#3b82f6', // Blue-500
        C: '#22c55e', // Green-500
      };

      const CLASS_NAMES = {
        A: 'Red Class',
        B: 'Blue Class',
        C: 'Green Class',
      };

      // --- UTILS (KNN Logic) ---

      const generateId = () => Math.random().toString(36).substr(2, 9);

      const calculateDistance = (p1, p2) => {
        return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
      };

      const classifyPoint = (queryPoint, points, k) => {
        if (points.length === 0) {
          return {
            predictedLabel: null,
            nearestNeighbors: [],
            voteCounts: { A: 0, B: 0, C: 0 },
          };
        }

        // 1. Calculate distances
        const distances = points.map((point) => ({
          point,
          distance: calculateDistance(queryPoint, point),
        }));

        // 2. Sort by distance
        distances.sort((a, b) => a.distance - b.distance);

        // 3. Pick top K
        const nearestNeighbors = distances.slice(0, Math.min(k, points.length));

        // 4. Vote
        const voteCounts = { A: 0, B: 0, C: 0 };
        nearestNeighbors.forEach((neighbor) => {
          voteCounts[neighbor.point.label]++;
        });

        // 5. Determine winner
        let maxVotes = -1;
        let winner = null;

        Object.keys(voteCounts).forEach((label) => {
          if (voteCounts[label] > maxVotes) {
            maxVotes = voteCounts[label];
            winner = label;
          }
        });

        return {
          predictedLabel: winner,
          nearestNeighbors,
          voteCounts,
        };
      };

      const generateRandomPoints = (count, width, height) => {
        const points = [];
        const labels = ['A', 'B']; 
        
        for (let i = 0; i < count; i++) {
          const cluster = Math.random() > 0.5 ? 0 : 1;
          const centerX = cluster === 0 ? width * 0.3 : width * 0.7;
          const centerY = cluster === 0 ? height * 0.3 : height * 0.7;
          const variance = width * 0.25;

          points.push({
            id: generateId(),
            x: Math.max(0, Math.min(width, centerX + (Math.random() - 0.5) * variance)),
            y: Math.max(0, Math.min(height, centerY + (Math.random() - 0.5) * variance)),
            label: labels[cluster],
          });
        }
        return points;
      };

      // --- ICONS (Inline SVGs to replace Lucide) ---

      const RefreshIcon = ({ size = 16, className = "" }) => (
        <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
          <path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8"/>
          <path d="M21 3v5h-5"/>
          <path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16"/>
          <path d="M3 21v-5h5"/>
        </svg>
      );

      const TrashIcon = ({ size = 16, className = "" }) => (
        <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
          <path d="M3 6h18"/><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"/><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"/><line x1="10" x2="10" y1="11" y2="17"/><line x1="14" x2="14" y1="11" y2="17"/>
        </svg>
      );

      const InfoIcon = ({ size = 16, className = "" }) => (
        <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
          <circle cx="12" cy="12" r="10"/><path d="M12 16v-4"/><path d="M12 8h.01"/>
        </svg>
      );

      // --- COMPONENTS ---

      const Controls = ({ k, setK, activeClass, setActiveClass, onGenerate, onClear, totalPoints }) => {
        return (
          <div className="w-full lg:w-80 bg-white p-6 border-r border-slate-200 flex flex-col gap-8 h-full overflow-y-auto shadow-sm z-10">
            <div>
              <h1 className="text-2xl font-bold text-slate-800 mb-2">KNN Mechanism</h1>
              <p className="text-slate-500 text-sm">
                Interactive visualization of the K-Nearest Neighbors algorithm.
              </p>
            </div>

            {/* K Value Slider */}
            <div className="space-y-4">
              <div className="flex justify-between items-center">
                <label htmlFor="k-slider" className="font-semibold text-slate-700">Value of K</label>
                <span className="bg-indigo-100 text-indigo-700 font-bold px-3 py-1 rounded-full">{k}</span>
              </div>
              <input
                id="k-slider"
                type="range"
                min="1"
                max="15"
                step="1"
                value={k}
                onChange={(e) => setK(Number(e.target.value))}
                className="w-full h-2 bg-slate-200 rounded-lg appearance-none cursor-pointer accent-indigo-600"
              />
              <p className="text-xs text-slate-500">K is the number of neighbors to vote.</p>
            </div>

            {/* Class Selector */}
            <div className="space-y-3">
              <label className="font-semibold text-slate-700">Add Data Points</label>
              <div className="flex flex-col gap-2">
                {Object.keys(CLASS_COLORS).slice(0, 2).map((label) => (
                  <button
                    key={label}
                    onClick={() => setActiveClass(label)}
                    className={`flex items-center justify-between px-4 py-3 rounded-lg border transition-all ${
                      activeClass === label
                        ? 'border-indigo-500 bg-indigo-50 ring-1 ring-indigo-500'
                        : 'border-slate-200 hover:bg-slate-50'
                    }`}
                  >
                    <div className="flex items-center gap-3">
                      <div className="w-4 h-4 rounded-full" style={{ backgroundColor: CLASS_COLORS[label] }} />
                      <span className="font-medium text-slate-700">{CLASS_NAMES[label]}</span>
                    </div>
                    {activeClass === label && <div className="w-2 h-2 bg-indigo-500 rounded-full" />}
                  </button>
                ))}
              </div>
            </div>

            {/* Actions */}
            <div className="space-y-3">
              <label className="font-semibold text-slate-700">Dataset</label>
              <div className="grid grid-cols-2 gap-3">
                <button
                  onClick={onGenerate}
                  className="flex items-center justify-center gap-2 px-4 py-2 bg-slate-100 text-slate-700 rounded-lg hover:bg-slate-200 transition-colors font-medium text-sm"
                >
                  <RefreshIcon /> Randomize
                </button>
                <button
                  onClick={onClear}
                  className="flex items-center justify-center gap-2 px-4 py-2 bg-red-50 text-red-600 rounded-lg hover:bg-red-100 transition-colors font-medium text-sm"
                >
                  <TrashIcon /> Clear
                </button>
              </div>
            </div>

            {/* Instructions */}
            <div className="mt-auto bg-slate-50 p-4 rounded-lg border border-slate-100">
              <div className="flex items-start gap-2">
                <InfoIcon className="text-indigo-500 mt-0.5 min-w-[16px]" />
                <div className="text-xs text-slate-600 space-y-2">
                  <p><strong>How to use:</strong></p>
                  <ul className="list-disc pl-4 space-y-1">
                    <li><strong>Click</strong> to add points.</li>
                    <li><strong>Hover</strong> to test classification.</li>
                    <li>Adjust <strong>K</strong> to see decision changes.</li>
                  </ul>
                </div>
              </div>
            </div>
          </div>
        );
      };

      const Visualization = ({ points, queryPoint, classification, onAddPoint, onUpdateQuery, activeClass, k }) => {
        const containerRef = useRef(null);
        const [dimensions, setDimensions] = useState({ width: 0, height: 0 });

        useEffect(() => {
          const updateSize = () => {
            if (containerRef.current) {
              const { width, height } = containerRef.current.getBoundingClientRect();
              setDimensions({ width, height });
            }
          };
          updateSize();
          window.addEventListener('resize', updateSize);
          return () => window.removeEventListener('resize', updateSize);
        }, []);

        const xScale = useMemo(() => d3.scaleLinear().domain([0, 100]).range([0, dimensions.width]), [dimensions.width]);
        const yScale = useMemo(() => d3.scaleLinear().domain([0, 100]).range([dimensions.height, 0]), [dimensions.height]);

        const handleSvgClick = (e) => {
          if (!containerRef.current) return;
          const rect = containerRef.current.getBoundingClientRect();
          const x = xScale.invert(e.clientX - rect.left);
          const y = yScale.invert(e.clientY - rect.top);
          onAddPoint({ id: Math.random().toString(36).substr(2, 9), x, y, label: activeClass });
        };

        const handleMouseMove = (e) => {
          if (!containerRef.current) return;
          const rect = containerRef.current.getBoundingClientRect();
          const x = xScale.invert(e.clientX - rect.left);
          const y = yScale.invert(e.clientY - rect.top);
          onUpdateQuery({ x, y });
        };

        const searchRadius = useMemo(() => {
          if (classification.nearestNeighbors.length < k) return 0;
          const lastNeighbor = classification.nearestNeighbors[classification.nearestNeighbors.length - 1];
          const pixelDist = xScale(lastNeighbor.distance) - xScale(0);
          return Math.abs(pixelDist);
        }, [classification, k, xScale]);

        const predictedColor = classification.predictedLabel ? CLASS_COLORS[classification.predictedLabel] : '#94a3b8';

        return (
          <div className="flex flex-col h-full relative">
            <div 
              ref={containerRef} 
              className="flex-grow relative bg-white rounded-xl shadow-inner border border-slate-200 overflow-hidden cursor-crosshair m-4"
            >
              {/* Grid Background */}
              <div className="absolute inset-0 pointer-events-none opacity-5" 
                   style={{ 
                     backgroundImage: 'linear-gradient(#000 1px, transparent 1px), linear-gradient(90deg, #000 1px, transparent 1px)', 
                     backgroundSize: '40px 40px' 
                   }} 
              />

              {dimensions.width > 0 && (
                <svg 
                  width={dimensions.width} 
                  height={dimensions.height} 
                  onClick={handleSvgClick}
                  onMouseMove={handleMouseMove}
                  className="absolute inset-0 z-10"
                >
                  {/* Lines to Neighbors */}
                  {queryPoint && classification.nearestNeighbors.map((neighbor) => (
                    <line
                      key={`line-${neighbor.point.id}`}
                      x1={xScale(queryPoint.x)}
                      y1={yScale(queryPoint.y)}
                      x2={xScale(neighbor.point.x)}
                      y2={yScale(neighbor.point.y)}
                      stroke={CLASS_COLORS[neighbor.point.label]}
                      strokeWidth={2}
                      strokeDasharray="4 4"
                      opacity={0.6}
                    />
                  ))}

                  {/* Search Radius */}
                  {queryPoint && searchRadius > 0 && (
                    <circle
                      cx={xScale(queryPoint.x)}
                      cy={yScale(queryPoint.y)}
                      r={searchRadius}
                      fill={predictedColor}
                      fillOpacity={0.1}
                      stroke={predictedColor}
                      strokeWidth={1}
                      strokeOpacity={0.4}
                    />
                  )}

                  {/* Data Points */}
                  {points.map((point) => {
                    const isNeighbor = classification.nearestNeighbors.some(n => n.point.id === point.id);
                    return (
                      <g key={point.id}>
                        {isNeighbor && (
                           <circle
                           cx={xScale(point.x)}
                           cy={yScale(point.y)}
                           r={12}
                           fill="none"
                           stroke={CLASS_COLORS[point.label]}
                           strokeWidth={2}
                           opacity={0.6}
                         />
                        )}
                        <circle
                          cx={xScale(point.x)}
                          cy={yScale(point.y)}
                          r={6}
                          fill={CLASS_COLORS[point.label]}
                          stroke="#fff"
                          strokeWidth={2}
                          className="transition-all duration-200"
                        />
                      </g>
                    );
                  })}

                  {/* Cursor / Query Point */}
                  {queryPoint && (
                    <g className="pointer-events-none">
                      <circle
                        cx={xScale(queryPoint.x)}
                        cy={yScale(queryPoint.y)}
                        r={8}
                        fill={predictedColor}
                        stroke="#1e293b"
                        strokeWidth={2}
                        className="drop-shadow-md"
                      />
                      <circle cx={xScale(queryPoint.x)} cy={yScale(queryPoint.y)} r={4} fill="#fff" />
                      <text
                        x={xScale(queryPoint.x)}
                        y={yScale(queryPoint.y) - 15}
                        textAnchor="middle"
                        className="text-xs font-bold fill-slate-700"
                        style={{ textShadow: '0 1px 2px white' }}
                      >
                        ?
                      </text>
                    </g>
                  )}
                </svg>
              )}
              
              {/* Floating Legend */}
              <div className="absolute top-4 right-4 bg-white/90 backdrop-blur p-4 rounded-lg shadow-lg border border-slate-200 w-64 pointer-events-none select-none">
                 <h3 className="text-xs font-bold uppercase tracking-wider text-slate-500 mb-2">Decision Logic</h3>
                 <div className="mb-3">
                   <div className="flex justify-between text-sm mb-1">
                     <span className="text-slate-600">Neighbors:</span>
                     <span className="font-mono font-bold">{classification.nearestNeighbors.length} / {k}</span>
                   </div>
                   <div className="w-full bg-slate-100 rounded-full h-1.5 overflow-hidden">
                     <div 
                       className="bg-indigo-500 h-full transition-all duration-300"
                       style={{ width: `${(classification.nearestNeighbors.length / k) * 100}%` }}
                     />
                   </div>
                 </div>
                 <div className="space-y-2">
                   {(Object.keys(classification.voteCounts)).map(label => {
                     if (classification.voteCounts[label] === 0) return null;
                     return (
                       <div key={label} className="flex items-center justify-between text-sm">
                         <div className="flex items-center gap-2">
                            <div className="w-2 h-2 rounded-full" style={{ backgroundColor: CLASS_COLORS[label] }} />
                            <span className="text-slate-700">{CLASS_NAMES[label]}</span>
                         </div>
                         <span className="font-bold text-slate-900">{classification.voteCounts[label]}</span>
                       </div>
                     )
                   })}
                 </div>
                 <div className="mt-4 pt-3 border-t border-slate-100 flex justify-between items-center">
                    <span className="text-sm font-semibold text-slate-600">Result:</span>
                    {classification.predictedLabel ? (
                       <span 
                        className="px-2 py-1 rounded text-xs font-bold text-white shadow-sm"
                        style={{ backgroundColor: CLASS_COLORS[classification.predictedLabel] }}
                       >
                         {CLASS_NAMES[classification.predictedLabel]}
                       </span>
                    ) : (
                      <span className="text-sm text-slate-400 italic">Uncertain</span>
                    )}
                 </div>
              </div>
            </div>
          </div>
        );
      };

      // --- MAIN APP COMPONENT ---

      const App = () => {
        const [points, setPoints] = useState([]);
        const [k, setK] = useState(3);
        const [activeClass, setActiveClass] = useState('A');
        const [queryPoint, setQueryPoint] = useState(null);
        
        const handleGenerate = () => {
          setPoints(generateRandomPoints(20, 100, 100));
        };

        useEffect(() => {
          handleGenerate();
        }, []);

        const handleUpdateQuery = useCallback((point) => {
          setQueryPoint(point);
        }, []);

        const classification = useMemo(() => {
          if (!queryPoint) return { predictedLabel: null, nearestNeighbors: [], voteCounts: { A: 0, B: 0, C: 0 } };
          return classifyPoint(queryPoint, points, k);
        }, [queryPoint, points, k]);

        return (
          <div className="flex flex-col lg:flex-row h-screen w-full bg-slate-50 overflow-hidden">
            <Controls 
              k={k}
              setK={setK}
              activeClass={activeClass}
              setActiveClass={setActiveClass}
              onGenerate={handleGenerate}
              onClear={() => setPoints([])}
              totalPoints={points.length}
            />
            <main className="flex-1 flex flex-col h-full overflow-hidden relative">
              <Visualization 
                points={points}
                queryPoint={queryPoint}
                classification={classification}
                onAddPoint={(p) => setPoints(prev => [...prev, p])}
                onUpdateQuery={handleUpdateQuery}
                activeClass={activeClass}
                k={k}
              />
              <div className="lg:hidden absolute bottom-0 w-full bg-white/80 p-2 text-center text-xs text-slate-500 backdrop-blur-sm">
                 Use desktop for best experience
              </div>
            </main>
          </div>
        );
      };

      // --- MOUNT ---
      const root = ReactDOM.createRoot(document.getElementById('root'));
      root.render(<App />);
    </script>
  </body>
</html>